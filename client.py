import socket
import threading
import time
import json
import os
from client_parser import Parser
from client_cli import Cli
#! thoughts for the future : we need to keep track of all sent messages
#! it might be useful to store our messages and their sending time in some structure

# TODO : send messages to multiple users
# TODO : hidden commands - commands that are sent by client programm that are not displayed in cli


class Client:
    def __init__(self):

        self.SERVERPORT = 5050
        self.HEADERSIZE = 64
        self.SERVERIP = "192.168.1.191"
        self.SERVERADDR = (self.SERVERIP, self.SERVERPORT)
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # flag that indicates whether we have to send message with current state
        self.to_send = False
        self.message_state = {
            "from": "a",
            "to": "a",
            "text": "",
            "time": "",
            "command": "",
            "delay": 0,
            # flag that indicates whether message should be resent or audited by server
            "not_notif_message": True  # if message is generated by user
        }
        self.user_commands = ["-s:", "-delay:", "-switch:",
                              "-disconnect:", "-delayall:"]  # for server from user , forgot about -info
        self.server_commands = {}  # commands generated by server
        self.hidden_commands = {}  # notification commands
        self.test_mode = False  # doesn't permit access to the Internet
        self.reset_delay = True
        # commands that are not sent to server
        self.setup_commands = ["-delay:", "-switch:", "-delayall:"]
        self.help_string = "This is help string "  # * needs change
        self.logged_in = False

    def exit_client(self):
        os._exit(0)

    def start(self):
        global Cli
        
        if not self.test_mode:
            try:
                self.sock.connect(self.SERVERADDR)
            except:
                print("ServerError: try again later")
                self.exit_client()
            else:
                self.login_process(self.sock)
                Cli = Cli(client,parser)
                Cli.start()
                data_thread = threading.Thread(
                    target=self.receive_data, args=(self.sock,))
                data_thread.start()

    # data from server is passed in 2 parts : message_length and message itself
    # there will be 3 types of messages: user messages, error messages and delivered messages

    def receive_data(self, socket):
        #! client doesn't differentiate server messages from user messages
        while True:
            message_len = socket.recv(64)
            formatted_msg_len = parser.format_message_length(
                message_len, False)
            message = socket.recv(formatted_msg_len)
            decoded_message = parser.format_message(message, for_server=False)
            is_server_message = True if decoded_message["from"] == "SERVER" else False
            if is_server_message:

                self.execute_server_generated_commands(decoded_message)

            else:
                print("Message from user: ", decoded_message, "\n\n")

    # one star near the message
    def execute_server_generated_commands(self, msg):
        command = msg["command"]
        error = msg["error"]
        if error:
            print(error.upper())
        if command == "-login_accept:":
            self.logged_in = True
            obtained_account_val = msg["to"]
            self.change_message_property("from",obtained_account_val)
            print(f"Successfully logged in as {obtained_account_val}")
        elif command == "-login_reject":
            print("Log-in error")
        # ....
        return 0

    def response_from_client(self):  # two stars near the message
        pass

    def login_process(self, socket):
        while not self.logged_in:
            account_name = input("Type name of your account: ")
            login_message_obj = {"text": account_name,  # ! if account_name is disconnect -> disconnect
                                 "from": "unknown",
                                 "delay": 0,
                                 "not_notif_message": True,
                                 "time": parser.get_time()
                                 }  # we create new message object not to change our global message state!
            login_message_formatted = parser.format_message(
                login_message_obj, for_server=True)
            message_len_formatted = parser.format_message_length(
                len(login_message_formatted), for_server=True)
            socket.send(message_len_formatted)
            socket.send(login_message_formatted)
            self.receive_login_response(socket)
        return 0
        # add field for password

    def change_message_property(self, name, value):
        self.message_state[name] = value

    def receive_login_response(self, socket):
        message_len = socket.recv(64)
        formatted_msg_len = parser.format_message_length(
            message_len, False)
        message = socket.recv(formatted_msg_len)
        decoded_message = parser.format_message(message, for_server=False)
        self.execute_server_generated_commands(decoded_message)

    def update(self, update):

        if update["command"] not in self.setup_commands:
            self.to_send = True  # sending immediately if not delay or switch comamnd
            if update["command"] == "-disconnect:":
                exit_timer = threading.Timer(2.0, self.exit_client)
                exit_timer.start()
                self.change_message_property("not_notif_message", True)
                # !need to clean message state # except from, time, not notif
            if update["command"] == "-s:":
                self.change_message_property("not_notif_message", True)
                self.change_message_property("text", update["text"])
            self.change_message_property("command", update["command"])
            self.change_message_property("time", update["time"])

        # don't consider time for delay and switch commands
        elif update["command"] == "-delay:":
            # we don't delay disconnect messages
            self.reset_delay = True
            self.change_message_property("delay", int(update["text"]))

        elif update["command"] == "-switch:":
            self.change_message_property("to", update["text"])

        elif update["command"] == "-delayall:":
            self.reset_delay = False
            self.change_message_property("delay", update["text"])

    # updates message state and sends message

    def update_message_state(self, msg):
        self.update(msg)  # updates message state
        # print(self.message_state, " message obj") # for testing
        if self.to_send == True:  # if send flag is true
            self.to_send = False
            raw_message = self.message_state
            formatted_message = parser.format_message(raw_message)
            formatted_msg_len = parser.format_message_length(
                len(formatted_message))
            if self.reset_delay == True:
                self.change_message_property("delay", 0)
            self.send(formatted_msg_len, self.sock)
            self.send(formatted_message, self.sock)
            # reset delay

    def send(self, msg, socket):
        if not self.test_mode:
            try:
                socket.send(msg)
            except:
                print("ServerError: try again later")
        else:
            print(msg)


parser = Parser()
client = Client()
client.start()
